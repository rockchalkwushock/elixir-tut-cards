# There are two types of docs Module & Function
# Examples must have a /n 3 tabs in /n

# defmodule Cards do
#   def create_deck do
#     values = ["Ace", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Jack", "Queen", "King"] # convention is double quotes.
#     suits = ["Spades", "Clubs", "Hearts", "Diamonds"]

#     # This is a "list comprehension"
#     # This is basically a for loop in elixir
#     # For every element in the list do this
#     # This is a map i.e. arr.map((val, i) => {}) returns copy of array
#     # String interpolation through Template Literals is present in Elixir
#     # "#{variable}"
#     for suit <- suits, value <- values do
#       "#{value} of #{suit}"
#     end
#   end
#   def shuffle(deck) do
#     Enum.shuffle(deck)
#   end
#   # ? no added functionality, this is a convention denotes a return value of true/false
#   def contains?(deck, card) do
#     Enum.member?(deck, card) # notice I can tell this will return true/false due to the ? convention
#   end
#   def deal(deck, hand_size) do
#     # tuples - an array in which the index means something important to me.
#     # first element is my hand
#     # second element is the rest of the deck.
#     # { hand, deck }
#     # { hand: [], deck: [] } JS example
#     # Accessing data from a Tuple: **Pattern Matching**
#     # Pattern Matching is Elixir's replacement for variable assignment (Grider's definition)
#     # >iex(1)> { hand, rest_of_deck } = Cards.deal(deck, 5)
#     # >iex(2)> hand # will return the hand generated by Cards.deal(deck, 5)
#     # >iex(3)> rest_of_hand # will return the rest of the deck.
#     # we assign the values to the defined variables
#     # this is like destructuring in JS:
#     # const { children, apples, ...rest } = this.props
#     # const [ firstIndex, secondIndex, ...rest ] = arr.map(val => { ... })
#     # basically { one, two } = { 1, 2 } match
#     # { one, two, three } = { 1, 2 } doesn't match yeilds MatchError will not be defined & iex will throw a fit.
#     Enum.split(deck, hand_size)
#   end
#   def save(deck, filename) do
#     # convert deck to an object that can be saved to a file.
#     binary = :erlang.term_to_binary(deck)
#     # Write the data to the file
#     File.write(filename, binary)
#   end
#   def load(filename) do
#     # success: { :ok, :binary }
#     # error: { :error, :enoent }
#     # Symbols
#     # :word = atom
#     # atoms usually refer to status codes, etc.
#     # think of them as Strings.
#     # Pattern Matching NOTE
#     # If we hard code a value on the left side we are telling Elixir
#     # this MUST MATCH end of discussion:
#     # ["red", color] = ["red", "blue"] Good
#     # ["red", color] = ["green", "blue123"] Will throw MatchError and color will still yield "blue"
#     case File.read(filename) do
#       # 1 Step, 2 individual processes
#       # #1 Comparison for case
#       # #2 Assignment of fileData to binary
#       # [:ok, binary] = [:ok, "fileData"]
#       {:ok, binary} -> :erlang.binary_to_term(binary)
#       # [:error, binary] = [:error, :enoent]
#       # to nullify a variable we don't need to use
#       # but is required for the tuple structure
#       # prefix with _
#       {:error, _reason } -> "File does not exist!"
#     end
#   end
#   def create_hand(hand_size) do
#     # The pipe operator REQUIRES consitent naming of first arguments
#     Cards.create_deck
#     |> Cards.shuffle
#     |> Cards.deal(hand_size)
#   end
# end


# # code I write > Elixir > Erlang > BEAM